// ---------------- [ File: bitcoinleveldb-table/src/block.rs ]
/*!
  | Decodes the blocks generated by
  | block_builder.cc.
  |
  */

crate::ix!();

//-------------------------------------------[.cpp/bitcoin/src/leveldb/table/block.h]

pub struct Block {

    data:           *const u8,
    size:           usize,

    /**
      | Offset in data_ of restart array
      |
      */
    restart_offset: u32,

    /**
      | Block owns data_[]
      |
      */
    owned:          bool,
}

unsafe impl Send for Block {}
unsafe impl Sync for Block {}

//-------------------------------------------[.cpp/bitcoin/src/leveldb/table/block.cc]
impl Drop for Block {
    fn drop(&mut self) {
        todo!();
        /*
            if (owned_) {
        delete[] data_;
      }
        */
    }
}

impl Block {

    pub fn size(&self) -> usize {
        
        todo!();
        /*
            return size_;
        */
    }
    
    #[inline] pub fn num_restarts(&self) -> u32 {
        
        todo!();
        /*
            assert(size_ >= sizeof(uint32_t));
      return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
        */
    }
    
    /**
      | Initialize the block with the specified
      | contents.
      |
      */
    pub fn new(contents: &BlockContents) -> Self {
    
        todo!();
        /*
        : data(contents.data.data()),
        : size(contents.data.size()),
        : owned(contents.heap_allocated),

            if (size_ < sizeof(uint32_t)) {
        size_ = 0;  // Error marker
      } else {
        size_t max_restarts_allowed = (size_ - sizeof(uint32_t)) / sizeof(uint32_t);
        if (NumRestarts() > max_restarts_allowed) {
          // The size is too small for NumRestarts()
          size_ = 0;
        } else {
          restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
        }
      }
        */
    }
    
    pub fn new_iterator(&mut self, comparator: Box<dyn SliceComparator>) -> *mut LevelDBIterator {
        
        todo!();
        /*
            if (size_ < sizeof(uint32_t)) {
        return NewErrorIterator(Status::Corruption("bad block contents"));
      }
      const uint32_t num_restarts = NumRestarts();
      if (num_restarts == 0) {
        return NewEmptyIterator();
      } else {
        return new Iter(comparator, data_, restart_offset_, num_restarts);
      }
        */
    }
}

/**
  | Helper routine: decode the next block entry
  | starting at "p", storing the number of shared
  | key bytes, non_shared key bytes, and the length
  | of the value in "*shared", "*non_shared", and
  | "*value_length", respectively.  Will not
  | dereference past "limit".
  |
  | If any errors are detected, returns nullptr.
  | Otherwise, returns a pointer to the key delta
  | (just past the three decoded values).
  */
#[inline] pub fn decode_entry(
        p:            *const u8,
        limit:        *const u8,
        shared:       *mut u32,
        non_shared:   *mut u32,
        value_length: *mut u32) -> *const u8 {
    
    todo!();
        /*
            if (limit - p < 3) return nullptr;
      *shared = reinterpret_cast<const uint8_t*>(p)[0];
      *non_shared = reinterpret_cast<const uint8_t*>(p)[1];
      *value_length = reinterpret_cast<const uint8_t*>(p)[2];
      if ((*shared | *non_shared | *value_length) < 128) {
        // Fast path: all three values are encoded in one byte each
        p += 3;
      } else {
        if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
        if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;
        if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
      }

      if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
        return nullptr;
      }
      return p;
        */
}

///--------------------
pub struct BlockIter {

    base:          LevelDBIterator,

    comparator:    Box<dyn SliceComparator>,

    /**
      | underlying block contents
      |
      */
    data:          *const u8,

    /**
      | Offset of restart array (list of fixed32)
      |
      */
    restarts:      u32,

    /**
      | Number of uint32_t entries in restart
      | array
      |
      */
    num_restarts:  u32,

    /**
      | current_ is offset in data_ of current
      | entry. >= restarts_ if !Valid
      |
      */
    current:       u32,

    /**
      | Index of restart block in which current_
      | falls
      |
      */
    restart_index: u32,

    key_:          String,
    value:         Slice,
    status:        Status,
}

impl BlockIter {

    #[inline] pub fn compare(&self, 
        a: &Slice,
        b: &Slice) -> i32 {
        
        todo!();
        /*
            return comparator_->Compare(a, b);
        */
    }

    /**
      | Return the offset in data_ just past
      | the end of the current entry.
      |
      */
    #[inline] pub fn next_entry_offset(&self) -> u32 {
        
        todo!();
        /*
            return (value_.data() + value_.size()) - data_;
        */
    }
    
    pub fn get_restart_point(&mut self, index: u32) -> u32 {
        
        todo!();
        /*
            assert(index < num_restarts_);
        return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
        */
    }
    
    pub fn seek_to_restart_point(&mut self, index: u32)  {
        
        todo!();
        /*
            key_.clear();
        restart_index_ = index;
        // current_ will be fixed by ParseNextKey();

        // ParseNextKey() starts at the end of value_, so set value_ accordingly
        uint32_t offset = GetRestartPoint(index);
        value_ = Slice(data_ + offset, 0);
        */
    }
    
    pub fn new(
        comparator:   Box<dyn SliceComparator>,
        data:         *const u8,
        restarts:     u32,
        num_restarts: u32) -> Self {
    
        todo!();
        /*
        : comparator(comparator),
        : data(data),
        : restarts(restarts),
        : num_restarts(num_restarts),
        : current(restarts_),
        : restart_index(num_restarts_),

            assert(num_restarts_ > 0);
        */
    }
    
    pub fn valid(&self) -> bool {
        
        todo!();
        /*
            return current_ < restarts_;
        */
    }
    
    pub fn status(&self) -> crate::Status {
        
        todo!();
        /*
            return status_;
        */
    }
    
    pub fn key(&self) -> Slice {
        
        todo!();
        /*
            assert(Valid());
        return key_;
        */
    }
    
    pub fn value(&self) -> Slice {
        
        todo!();
        /*
            assert(Valid());
        return value_;
        */
    }
    
    pub fn next(&mut self)  {
        
        todo!();
        /*
            assert(Valid());
        ParseNextKey();
        */
    }
    
    pub fn prev(&mut self)  {
        
        todo!();
        /*
            assert(Valid());

        // Scan backwards to a restart point before current_
        const uint32_t original = current_;
        while (GetRestartPoint(restart_index_) >= original) {
          if (restart_index_ == 0) {
            // No more entries
            current_ = restarts_;
            restart_index_ = num_restarts_;
            return;
          }
          restart_index_--;
        }

        SeekToRestartPoint(restart_index_);
        do {
          // Loop until end of current entry hits the start of original entry
        } while (ParseNextKey() && NextEntryOffset() < original);
        */
    }
    
    pub fn seek(&mut self, target: &Slice)  {
        
        todo!();
        /*
            // Binary search in restart array to find the last restart point
        // with a key < target
        uint32_t left = 0;
        uint32_t right = num_restarts_ - 1;
        while (left < right) {
          uint32_t mid = (left + right + 1) / 2;
          uint32_t region_offset = GetRestartPoint(mid);
          uint32_t shared, non_shared, value_length;
          const char* key_ptr =
              DecodeEntry(data_ + region_offset, data_ + restarts_, &shared,
                          &non_shared, &value_length);
          if (key_ptr == nullptr || (shared != 0)) {
            CorruptionError();
            return;
          }
          Slice mid_key(key_ptr, non_shared);
          if (Compare(mid_key, target) < 0) {
            // Key at "mid" is smaller than "target".  Therefore all
            // blocks before "mid" are uninteresting.
            left = mid;
          } else {
            // Key at "mid" is >= "target".  Therefore all blocks at or
            // after "mid" are uninteresting.
            right = mid - 1;
          }
        }

        // Linear search (within restart block) for first key >= target
        SeekToRestartPoint(left);
        while (true) {
          if (!ParseNextKey()) {
            return;
          }
          if (Compare(key_, target) >= 0) {
            return;
          }
        }
        */
    }
    
    pub fn seek_to_first(&mut self)  {
        
        todo!();
        /*
            SeekToRestartPoint(0);
        ParseNextKey();
        */
    }
    
    pub fn seek_to_last(&mut self)  {
        
        todo!();
        /*
            SeekToRestartPoint(num_restarts_ - 1);
        while (ParseNextKey() && NextEntryOffset() < restarts_) {
          // Keep skipping
        }
        */
    }
    
    pub fn corruption_error(&mut self)  {
        
        todo!();
        /*
            current_ = restarts_;
        restart_index_ = num_restarts_;
        status_ = Status::Corruption("bad entry in block");
        key_.clear();
        value_.clear();
        */
    }
    
    pub fn parse_next_key(&mut self) -> bool {
        
        todo!();
        /*
            current_ = NextEntryOffset();
        const char* p = data_ + current_;
        const char* limit = data_ + restarts_;  // Restarts come right after data
        if (p >= limit) {
          // No more entries to return.  Mark as invalid.
          current_ = restarts_;
          restart_index_ = num_restarts_;
          return false;
        }

        // Decode next entry
        uint32_t shared, non_shared, value_length;
        p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
        if (p == nullptr || key_.size() < shared) {
          CorruptionError();
          return false;
        } else {
          key_.resize(shared);
          key_.append(p, non_shared);
          value_ = Slice(p + non_shared, value_length);
          while (restart_index_ + 1 < num_restarts_ &&
                 GetRestartPoint(restart_index_ + 1) < current_) {
            ++restart_index_;
          }
          return true;
        }
        */
    }
}
